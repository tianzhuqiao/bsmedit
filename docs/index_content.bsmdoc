{!exec|firstRunOnly||{%
@BFunction('example')
def bsmdoc_example(data, *args, **kwargs):
    return bsmdoc_div(data, 'bs-example')
@BFunction('example_src')
def bsmdoc_example_src(data, *args, **kwargs):
    return bsmdoc_div(data, 'bs-example-src')
@BFunction('ccodesnippet')
def bsmdoc_ccodesnippet(data, *args, **kwargs):
    with open(data.strip(), 'r') as f:
        return ''.join(f.readlines())
    return data
bsmdoc_image_orig = BFunction().image
@BFunction('image')
def bsmdoc_image(data, *args, **kwargs):
    filename = data.strip()
    if filename.endswith('png'):
        from PIL import Image
        im = Image.open(data.strip())
        width, height = im.size
        args = list(args)
        args.append(f'width="{int(width/2)}"')
        args.append(f'height="{int(height/2)}"')
    return bsmdoc_image_orig(data, *args, **kwargs)
bsmdoc_video_orig = BFunction().video
@BFunction('video')
def bsmdoc_video(data, *args, **kwargs):
    filename = data.strip()
    if filename.endswith('mp4'):
        import cv2
        vid = cv2.VideoCapture(filename)
        height = vid.get(cv2.CAP_PROP_FRAME_HEIGHT)
        width = vid.get(cv2.CAP_PROP_FRAME_WIDTH)
        args = list(args)
        args.append(f'width="{int(width/2)}"')
        args.append(f'height="{int(height/2)}"')
    return bsmdoc_video_orig(data, *args, **kwargs)

import inspect
import bsmedit.bsm.sim
@BFunction('sim_interface_args')
def bsmdoc_sim_interface_args(data, *args, **kwargs):
    import bsmedit.bsm.simprocess
    data = data.strip()
    return f"{data}{bsmedit.bsm.simprocess.SimInterface.all_interfaces[data]['args']}"

@BFunction('sim_interface_args2')
def bsmdoc_sim_interface_args2(data, *args, **kwargs):
    data = data.strip()
    args = str(inspect.signature(getattr(bsmedit.bsm.sim.Simulation, data)))
    return f"{data}{args.replace('self, ', '')}"

@BFunction('sim_interface_docs')
def bsmdoc_sim_interface_docs(data, *args, **kwargs):
    import bsmedit.bsm.simprocess
    data = data.strip()
    return bsmedit.bsm.simprocess.SimInterface.all_interfaces[data]['doc']


%}!}

= What is bsmedit
bsmedit is a C++/[http://accellera.org/community/systemc|SystemC] Visualizer. Long time ago, when I first used the Systemc library to simulate some communication algorithms, I was quickly bored with the following debugging procedure:
* update the source code;
* re-compile the program;
* check the results.

And occasionally, I would need to add some debugging code. For example, printing some value (e.g., \tag{b|printf}) to the terminal or dumping the data to a file, so that I can use other tools (e.g., Matlab) to visualize and analyze it.

bsmedit aims to simplify this procedure. With bsmedit, we can
    -control C/C++/SystemC simulation
    -monitor/visualize signals in real-time
    -visualize VCD (value change dump) files
    -visualize ulog files
    -...

= Get started
bsmedit can be installed with pip
{!example_src||highlight|shell||{%
$ pip install bsmedit
%}!}

You can also clone the repository and run
{!example_src||highlight|shell||{%
$ cd bsmedit
$ pip install -e .
%}!}

== Create a SystemC simulation
To use bsmedit, the first step is to build a simulation. In the following example, we will create a dummy SystemC simulation that outputs a synchronized $\sin$ and $\cos$ waveforms.

* \tag{b|Create a simulation project.} You can use your preferred platform and compiler.
* {\tag{b|Add SystemC support to your project.} To make the simulation work with bsmedit, you need a modified SystemC, which can be got [https://github.com/tianzhuqiao/systemc|here], all the branches started with \tag{b|bsm_} are supported by bsmedit. Currently it supports the following SystemC releases
- 3.0.0_pub_rev_20231129
- 2.3.4
- 2.3.3
- 2.3.2
- 2.3.1a

{!div|info||
Please refer to the file [https://github.com/tianzhuqiao/bsmedit/blob/master/systemc-2.3.1/INSTALL|INSTALL] in the SystemC package about how to add SystemC support to your project.
!}
}
* \tag{b|Implement the simulation.}
*- {Create a top level SystemC module \tag{b|top}, which may look like
{!example_src||highlight|c++||ccodesnippet||
../examples/start/top.h
!}
The top module is derived from \tag{b|sc_module}. It defines several signals used in the module
- \tag{b|clock}: the module is triggered by the positive edge of the clock, whose period is $10ns$ with 50\% duty cycle. One thing to notice is that the signal \tag{clock} is given a name \tag{b|CLOCK}. bsmedit will use this name to have access to this signal. At shown in the example, the name of the signal (i.e., CLOCK) may not be same as the variable name (i.e., clock), although in practice they are often same for convenience.
- \tag{b|sig_sin}: the signal for the sine waveform, whose name is \tag{b|sig_sin}.
- \tag{b|sig_cos}: the signal for the cos waveform, whose name is \tag{b|sig_cos}.
- \tag{b|sig_steps}: the phase step for each clock, which is increased by $\frac{\pi}{\textrm{sig_steps}}$. The phase is initialized to be zero.
The module also defines a process method (i.e., \tag{b|Action}). It is triggered at each rising edge of \tag{b|clock} (also called positive edge), where all calculations are conducted.
}
*-{The \tag{b|top.cpp} may look like
{!example_src||highlight|c++||ccodesnippet||
../examples/start/top.cpp
!}
In the process method (\tag{b|Action}), we simply update the sin/cos signals based on the current phase. Then, update the phase for the next step. In this demo, the maximum step is assumed to be $\frac{\pi}{256}$.
}
*-{The \tag{b|main} function may look like
{!example_src||highlight|c++||ccodesnippet||
../examples/start/main.cpp
!}

Besides the SystemC library, it also needs to include the \tag{b|bsm.h/cpp} in the project. They define interfaces to communicate with bsmedit
-\tag{b|BSMEDIT_IMPLEMENT_MODULE(top, "top")} creates the top level module from class \tag{b|top} with name "top".
We will discuss the macro in detail in the following sections.
}
*- {The makefile may look like
{!example_src||highlight|makefile||ccodesnippet||
../examples/start/Makefile
!}
When compile the simulation, the compiler setting (e.g., \tag{b|CC} in the above makefile) needs to be same as the one used to compile the SystemC library.
}
* \tag{b|Compile the project to get simulation} (e.g., \tag{b|start.dll})
{!div|info||
The demo project can be download [https://github.com/tianzhuqiao/bsmedit/tree/master/examples/start|here].
!}
== Open with bsmedit
{!div|info||
Make sure your simulation architecture match with python. For example, if your simulation is \tag{b|x64}, you should also install the \tag{b|x64} version python. Otherwise, bsmedit will fail to load the simulation.
!}

Start bsmedit by
{!example_src||highlight|shell||{%
$ bsmedit
%}!}

and create the simulation\footnote{Here we slightly abuse the notation \tag{b|simulation}. It may be indicated as either the binary from the simulation project or the simulation instance in bsmedit.} from the menu
{!image||
./images/start_open_project.png
!}

It will show a open file dialog to select the simulation library (e.g. \tag{b|libstart.so}, \tag{b|start.dll} ). Then bsmedit will load the simulation.
{!image||
./images/start_sim_main.png
!}
The main window consists of 4 sections, from top to bottom:
*{\tag{b|Simulation control toolbar}. From left to right:
-\tag{b|step}: run simulation in one step. You can arbitrarily define step duration. As we will show shortly, it is different from the \tag{b|delta} cycle concept in SystemC simulation.
-\tag{b|run}: run simulation until it is paused or total simulation duration is reached.
-\tag{b|pause}: pause simulation.
-\tag{b|step duration}: the duration of each simulation step. At the end of each simulation step, bsmedit will retrieve the data from the simulation and update the GUI (e.g., the time-stamp).
-\tag{b|step unit}: the time unit of each simulation step.
-\tag{b|total duration}: the total simulation duration. bsmedit will pause the simulation if the current simulation time exceeds the total simulation time. \tag{b|-1} to run simulation infinitely.
-\tag{b|total unit}: the time unit of the total simulation duration.
}
*{\tag{b|Simulation objects}\footnote{Sometimes they will be referred as \tag{b|objects} (as they are all derived from \tag{b|sc_object}) or \tag{b|signals} (as \tag{b|sc_signal} is the most common object to control the simulation). We will use both interchangeably.}.
This window lists all \tag{b|objects} defined in the simulation. As shown in figure above, the simulation has one top module (i.e., \tag{b|top}) and 4 signals: \tag{b|CLOCK}, \tag{b|sig_cos}, \tag{b|sig_sin}, and \tag{b|sig_steps}. The tree hierarchy represents their structure in the simulation.
}
*\tag{b|Console window}. It is used to execute commands and show outputs.
*\tag{b|Statusbar}.

To run the simulation, click the \tag{b|step} or \tag{b|run} button. The simulation will proceed until you pause it or the total simulation duration is reached. The current simulation time is shown in the status bar.

It is not very useful if bsmedit can only control the simulation running. bsmedit also allows you to monitor the signal values in real-time: select the signal to be monitored, and right click on it
{!image||
./images/start_sim_add2reg.png
!}

bsmedit will create a \tag{b|propgrid} window and add the selected signals to it.
{!image||
./images/start_sim_reg.png
!}

Click the \tag{b|run} button to start the simulation. The signal value will be updated automatically.
{!video||
./images/start_run.mp4
!}

You can also modify the signal values, for example, by typing the following commands in the console window
{!example_src||highlight|shell||{%
>>> # get the simulation handle
>>> s = simulation(1)
>>> # set the number of steps
>>> s['top.sig_steps'] = 8192
%}!}
The first command gets the handle of the simulation. Then, the second command sets the value of signal \tag{b|top.sig_steps} to 8192.

You can also plot the trace to see the signal trend,
{!example_src||highlight|shell||{%
>>> # trace the cos waveform to a buffer with size 4096
>>> s.trace_buf('top.sig_cos', 4096)
>>> # trace the sine waveform to a buffer with size 4096 too
>>> s.trace_buf('top.sig_sin', 4096)
>>> # plot the trace
>>> plot_trace('top.sig_cos', 'top.sig_sin', relim=False)
>>> xlim([-1,1])
>>> ylim([-1,1])
%}!}

The first command tells bsmedit to start tracing the signal \tag{b|top.sig_cos}; and the buffer length is 4096. In other words, its latest 4096 values will be stored in a numpy array. Similarly, the second command traces the signal \tag{b|top.sig_sin}. The third command creates a figure to plot \tag{b|top.sig_cos} as $x$ axis value and \tag{b|top.sig_sin} as $y$ axis. The last two lines set the limits of $x$ axis and $y$ axis, respectively. The created figure looks like
{!image||
./images/start_sim_plot.png
!}
It does not really show anything, since we just create the buffer and it has not be filled with signal values yet. When you run the simulation, the buffer will be filled and the plot will be updated accordingly
{!video||
./images/start_run_plot.mp4
!}

You can following the above steps to start the simulation and monitor the signals each time. However, it is too tedious to repeat each step again and again. In bsmedit, you can write a python script to do all the steps. The script may look like
{!example_src||highlight|python||ccodesnippet||{%
../examples/start.py
%}!}

Save the script to a file (e.g., [https://github.com/tianzhuqiao/bsmedit/blob/master/examples/start.py|start.py]).
Then, it can be opened in bsmedit
{!image||
./images/start_sim_open.png
!}

And it will look like the one shown in the following image. Click the \tag{b|Execute the script} button to run the script
{!image||
./images/start_open_script.png
!}

bsmedit will load the simulation, create a propgrid window, monitor the signals, and create a figure to plot the signals.
{!image||
./images/start_run_script.png
!}

= How it works
bsmedit was initially written in C++, which can be found [https://sourceforge.net/projects/bsmedit/|here]. It looks like an ideal choice since the simulation is also written in C/C++/SystemC. It supports multiple platforms (e.g., windows, linux), as the GUI is based on [http://www.wxwidget.org|wxWidget].

It is highly extensible thanks to the plugin system. Actually most functions as you seen above were implemented with the plugin system. For example, one plugin is used to control the simulation (e.g., start, pause, stop, resume), which also supports breakpoints (e.g., pause the simulation when some conditions are satisfied; thus, you can check the status of your algorithm at that time.). One plugin is to plot the data captured from the simulation, which mimics some features from Matlab \tag{b|plot} function: you can visualize the data in real-time and check its trend dynamically. One plugin adds some basic DSP functions (e.g., max, min, median, addition, subtraction, multiplication (dot product), square, square root, log/exp, sin/cos, acos/asin, tan, FFT etc.). It also had a console window so that you can run python command (e.g., to control the simulation)...

Following this way, we could build bsmedit block by block. At that time, I though it would work. However, such method has some significant drawbacks. One big problem is that we need to re-invert many many wheels. For example, after implement some functions, bsmedit also needs to wrap all these functions in python, so that you can call it in python script or in the console window. No need to say how tedious and error-prone such process is. How about adding a DSP function that does not exist in bsmedit (e.g., a moving average)? Basically, you will have to create a plugin project following the template, and write code to implement the actual processing.
We try hard to make the interface as simple as possible; but it still requires some significant effort to make such plugin work. Furthermore, how about adding some features to the plot library? It will be a real nightmare to go through all the code to find the right position to add some code...

To solve these issues, from version 3, bsmedit is totally rewritten with python (wxPython for GUI). But, it does not mean you need to write your simulation in python. The simulation is still in C/C++/SystemC, and bsmedit will load and run the simulation as usual. Since it is in python, all functions can be directly called by python script and no need to wrap the interfaces any more. No need to provide a custom plot library, since you can just use the existing python libraries (e.g., matplotlib). No need to write many basic DSP function, which can be easily fulfilled with numpy or scipy...

== Console window
In version 3, the python console window is replaced with a native interactive interpreter (wx.py.shell). It allows you to run arbitrary python command.

It is not fun to remember all the commands. When typing a '\tag{b|.}', bsmedit will show an auto-complete list for you to select from, if there is any
{!image||
./images/console_autocomplete.png
!}

Similarly, it will also try to show the calltips of a function when it sees a '\tag{b|(}'
{!image||
./images/console_calltip.png
!}

#And you can also use the \tag{code|help} command to get the doc of a command, for example
#{!example_src||highlight|shell||{%
#>>> help run
#Help on function run in module bsm.pysim:
#
#run(*args, **kwargs)
#    run(to=None, more=None)
#
#    keep running the simulation
#
#    The simulation is executed step by step. After each step, the simulation
#    'server' will notify the 'client' to update the GUI.
#%}!}

It also supports executing external command. The external command should be prepended by '\tag{b|\!}'. For example, to list the contents in the current folder by calling '\tag{b|ls}' command (see [http://unxutils.sourceforge.net/|here] for windows system)
{!example_src||highlight|shell||{%
>>> !ls
%}!}
You can also pass arguments to the external command
{!example_src||highlight|shell||{%
>>> !ls -l
%}!}

By default, when executing the external command, bsmedit will wait for it to finish, then show its output in the console window. Command can also be executed in background by appending a '\tag{b|&}'. For example, the following command will open a gvim window and return (without '\tag{b|&}', it will not return until the gvim window is closed)
{!example_src||highlight|shell||{%
>>> !gvim &
%}!}

You can add an \tag{b|alias} to an external command to save some typing. For example, the following command will add an alias \tag{b|ll}
{!example_src||highlight|shell||{%
>>> alias ll ls -l
%}!}
where the first parameter is the alias name (e.g., \tag{b|ll}), and the remaining parameters are the destination (e.g. \tag{b|ls -l}).
Now, when the console sees input \tag{b|ll}, it will automatically replace it with \tag{b|!ls -l}, and execute it. If an alias definition does not include a destination, it will be deleted if exists. For example, the following code will delete the alias \tag{b|ll}
{!example_src||highlight|shell||{%
>>> alias ll
%}!}

There are some pre-defined commands (by wx.py.shell), which are frequently used. Thus, you still can used it even if these external commands are not installed.
{!example_src||highlight|shell||{%
>>> cd DIR # go the DIR folder
>>> pwd # show the current working directory
>>> ls # list the current working directory
>>> clear # clear the console window
%}!}

It is also able to run the command silently by appending '\tag{b|;}'. In other words, to execute the command without showing any output in the console window.
{!example_src||highlight|shell||{%
>>> # define a function foo
>>> def foo():
...    print('foo')
...    return 42
...
>>> # call a function with output
>>> a = foo()
foo
>>> # call a function silently
>>> a = foo();
>>>
%}!}

One major constraint of version 3 is that it executes the command in the main GUI thread. Thus, if a dead loop is fed into the interpreter, it will never return and can not be interrupted, for example:

{!example_src||highlight|python||{%
>>> while True:
...    pass
%}!}

One reason we do not execute the command in a separate process or thread is that some command may create GUI window. If the GUI window is created in separate process/thread, it will potentially cause many problems and significantly increase the complexity to handle the GUI window. However, in bsmedit, most time-consuming task should be the simulation itself, not the command or processing. Thus, the console command should not occupy too much time to block the GUI updating.

#Another concern is that we may totally separate the simulation control and GUI, such that you can use the simulation control function with any other interactive shell.

== Figure
In version 3, the original plot library is discarded. Instead, we use [http://www.matplotlib.org|matplotlib] to visualize the data. By default, all the functions defined in \tag{b|matplotlib.pyplot} are pre-loaded, so you can call them directly in the console window. The detailed description can be found [http://matplotlib.org/api/pyplot_api.html|here]. To create a new figure and plot a straight line
{!example_src||highlight|python||{%
>>> figure();
>>> plot(range(100))
%}!}
and the figure will look like
{!image||
./images/plot_range100.png
!}

Like Matlab, you can add label, legend, and grid
{!example_src||highlight|python||{%
>>> xlabel('x')
>>> ylabel('y')
>>> grid(ls='dotted')
>>> legend(['line1'], loc='best')
%}!}
{!image||
./images/plot_range100more.png
!}

As shown above, the figure window has two sections: \tag{b|toolbar} and \tag{b|plot}.
The buttons on the toolbar are (from left to right)
- \tag{b|new figure}: create an empty figure
- \tag{b|home}: it will bring the plot to the initial status (e.g., zoom and position)
- \tag{b|back}: go to the previous status if available
- \tag{b|forward}: go to the next status if available
- \tag{b|move/pan}: move the plot with the mouse
- \tag{b|zoom}: zoom in the plot by clicking, moving and releasing mouse, or with the mouse wheel. Double-click on the plot will bring the plot to the original view.
- {\tag{b|datatip}: add datatip to the curve.
{!image||{%
./images/figure_datatip.png
%}!}
# todo: export the datatip coordinate to a numary array

datatip can be activated by clicking on it and its background will be in orange. In this case, you can drag the datatip around to align it in different position.
}
- \tag{b|save}: export the plot (without the toolbar section) to a file (e.g., with format eps, ps, pgf, png, pdf, raw, rgba, svg ... )
- \tag{b|copy}: copy the plot (without toolbar section) to clipboard
- {\tag{b|edit}: edit the plotted lines
{!video||
./images/figure_edit.mp4
!}
}
The \tag{b|plot} function will add the curve to the \tag{b|active} figure window. Generally, the \tag{b|active} figure window is the latest activated figure window. For example, you can click on a figure window to make it active. And it will keep active until you click on another figure window or create a new one. If you are not sure about the active figure window, you may click on it before calling any plot functions. For a figure with multiple subplots, click the one to activate it
{!video||
./images/figure_select_axis.mp4
!}

The following command will activate the figure window with number \tag{b|1} (its window name may look like "\tag{b|Figure 1}")
{!example_src||highlight|python||{%
>>> figure(1)
%}!}

You can also get the handle of the current figure with
{!example_src||highlight|python||{%
>>> # get a reference to the current figure
>>> gcf()
>>> # get the current axes on the current figure
>>> gca()
%}!}
Refer to the [http://matplotlib.org/api/pyplot_api.html|Matplotlib doc] for more details.

== Simulation
One problem in version 2 is that the [http://www.systemc.org|SystemC]
simulation runs in a thread, and it may crash, which may in turn crashes
bsmedit. In version 3, the simulation runs in a separate process, which
receives command from the main process (e.g., interactive interpreter),
executes it and sends the response back. In this way, the simulation can
gracefully exit without affecting the main process.

As you have seen above, bsmedit defines functions to control the simulation
- {\tag{b|Create a simulation.}
{!example_src||highlight|python||
s = simulation\eval{str(inspect.signature(bsmedit.bsm.sim.sim.simulation))}
!}
where
{{
    \tag{strong|num}|the simulation id. If a simulation with \tag{b|num} is found, its handler will be returned||-
    \tag{strong|filename}| the simulation path||-
    \tag{strong|silent}|
    -False: open a file dialog to select a simulation if \tag{b|filename} is not given
    -True: do not show a file dialog||-
    \tag{strong|create}|create a simulation if can not find a simulation||-
    \tag{strong|activate}| activate the simulation window if it is True||-
}}
If the function is executed successfully, it will return the handler to the simulation, which can be used to control the simulation or have access to its objects.
For example
{!example_src||highlight|python||{%
# create a simulation and load 'mysimulation.dll'
s = simulation(filename='./mysimulation.dll')
# return the handler of the simulation #1 if it is available
s = simulation(1)
%}!}
}
-{\tag{b|Load the simulation.}
{!example_src||highlight|python||{%
s.load(filename=None)
%}!}
where the parameter \tag{b|filename} is the path to the simulation. If a simulation has already been loaded, \tag{b|load} will unload it first.

If \tag{b|filename} is \tag{b|None}, a file-select dialog will be shown to select the simulation.
}
-{\tag{b|Set simulation parameters.}
{!example_src||highlight|python||
s.\sim_interface_args{set_parameter}
!}
where
{{
\tag{strong|step}| the time duration of each step, e.g., "\tag{b|100us}". The pre-defined time units include \tag{b|fs} (femtosecond), \tag{b|ps} (picosecond), \tag{b|ns} (nanosecond), \tag{b|us} (microsecond), \tag{b|ms} (millisecond), and \tag{b|s} (second).||-
\tag{strong|total}| the total simulation duration; \tag{b|\-1} means to run infinitely.||-
\tag{strong|to} | pause simulation when simulation time reaches \tag{b|to} (or \tag{b|total}).||-
\tag{strong|more} | run simulation for additional time defined by \tag{b|more}, then pause. If \tag{b|to} is also defined, \tag{b|to} has higher priority.||-
}}
For example
{!example_src||highlight|python||{%
# set the step to be 1000us, and run infinitely
s.set_parameter(step='1000us', total='-1')
# set the step to be 1000. Here unit is not given, so the current one will be used. The default unit is 'ns'
s.set_parameter(step='1000', total='-1')
# When 'run' the simulation, it will stop at 100ms
s.set_parameter(to='100ms')
# When 'run' the simulation, it will stop at 100ms from the current simulation time-stamp
s.set_parameter(more='100ms')
%}!}
}
- {\tag{b|Run the simulation.} There are several functions to start the simulation
{!example_src||highlight|python||{%
# run the simulation for a single step with current settings (step, total)
s.step()
# run the simulation with the current settings (step, total)
s.run()
# run the simulation until 1ms
s.run(to='1ms')
# run the simulation for additional 1ms
s.run(more='1ms')
%}!}

Sometime, you may want to wait until the simulation pauses. For example, you may want to check the signal value after the simulation has paused. There is a function to do that
{!example_src||highlight|python||{%
s.wait_until_simulation_paused()
s.read('top.sig_sin')
%}!}
It will return only if the simulation is valid and has paused (in this case, it will return \tag{b|True}), or the simulation is invalid (return \tag{b|False}). And the second line \tag{b|s.read} will not be called until \tag{b|s.wait_until_simulation_paused} has returned. You can also set the timeout. For example, the following command will wait for a maximum period of \tag{b|10s}
{!example_src||highlight|python||{%
s.wait_until_simulation_paused(10)
%}!}
Here \tag{b|10s} is the 'PC time', not the simulation time.
}
- {\tag{b|Pause the simulation.}
{!example_src||highlight|python||{%
s.pause()
%}!}
It will pause the simulation, but not destroy it. In other words, you can resume the simulation by calling \tag{b|step} or \tag{b|run} mentioned above. To permanently destroy the simulation, you can call
{!example_src||highlight|python||{%
s.stop()
%}!}
}
- {\tag{b|Reset the simulation.}
{!example_src||highlight|python||{%
s.reset()
%}!}
It will close the current simulation, and reload it. Thus, when it is executed successfully, the simulation time will be reset to \tag{b|0}.
}
- {\tag{b|Read signals.} bsmedit defines function to have access to the signals in the simulation, for example
{!example_src||highlight|python||{%
>>> # read a single signal
>>> s.read("top.sig_cos")
0.7958369046061
%}!}
Besides calling the \tag{b|read} function explicitly, you can also use a shortcut
{!example_src||highlight|python||{%
>>> # same as the previous command
>>> s["top.sig_cos"]
0.7958369046061
%}!}

You can also read multiple signals with one command. In this case, the return value will be a \tag{b|dict}, whose key is the signal name.
{!example_src||highlight|python||{%
>>> # read multiple signals
>>> s.read(['top.sig_cos', 'top.sig_sin'])
{'top.sig_sin': 0.60551104140799, 'top.sig_cos': 0.7958369046061}
>>> # equivalent to
>>> s[['top.sig_cos', 'top.sig_sin']]
{'top.sig_sin': 0.60551104140799, 'top.sig_cos': 0.7958369046061}
>>> # equivalent to
>>> s['top.sig_cos', 'top.sig_sin']
{'top.sig_sin': 0.60551104140799, 'top.sig_cos': 0.7958369046061}
%}!}

For SystemC simulation, bsmedit supports the following data types. The right column shows the corresponding data type in python.
{{
SystemC type | Python type ||+
-float, double | float||-
-bool,
-char, unsigned char
-short, unsigned short
-int, unsigned int
-long, unsigned long
-long long, unsigned long long
-sc_logic, sc_bit| long||-
-sc_lv, sc_bv
-sc_int, sc_uint
-sc_bigint, sc_biguint
-sc_fixed
-sc_fixed_fast
-sc_ufixed
-std::string\footnote{only support \tag{b|sc_signal.}}|string||-
}}
And you can use the above function to read all the \tag{b|sc_signal}, \tag{b|sc_out}, \tag{b|sc_inout}, and \tag{b|sc_in} objects.
}
- {\tag{b|Write signals.} To update the signal value, you can call
{!example_src||highlight|python||{%
s.write(objects)
%}!}
where \tag{b|objects} is a \tag{b|dic} with the signal name as its key. bsmedit supports writing all the \tag{b|sc_signal}, \tag{b|sc_out}, and \tag{b|sc_inout}\footnote{\tag{b|sc_in} is not writable.}.

Due to the two-step mechanism in SystemC, in most cases, the value will be updated after the next delta cycle. That is, if a \tag{b|read} is called after \tag{b|write} immediately, it may return the previous value.

{!example_src||highlight|python||{%
>>> s.read('top.sig_steps')
256
>>> s.write({'top.sig_steps': 8192})
>>> s.read('top.sig_steps')
256
%}!}

Like \tag{b|read}, there is also a shortcut to write the signal
{!example_src||highlight|python||{%
>>> # same as the command above
>>> s['top.sig_steps'] = 8192
%}!}

Similarly, you can also write to multiple signals by calling \tag{b|write} once
{!example_src||highlight|python||{%
>>> # write multiple signals
>>> s.write({'top.sig_steps': 8192, 'top.sig_sin': 0.1})
>>> # same as the command above
>>> s[['top.sig_steps', 'top.sig_sin']] = [8192, 0.1]
>>> # or
>>> s['top.sig_steps', 'top.sig_sin'] = [8192, 0.1]
%}!}
}

- { \tag{b|Dump signal to numpy array.} For example, by calling the following command
{!example_src||highlight|python||{%
>>> s.trace_buf('top.sig_cos', size=10)
%}!}
bsmedit will dump the values of \tag{b|top.sig_cos} to a numpy array, so you can manipulate it easily. In the above example, the buffer size is \tag{b|10}. If the size is not set, the default size will be 256. Then, the buffer can be accessed by
{!example_src||highlight|python||{%
>>> buf = s.read_buf('top.sig_cos')
>>> type(buf)
<type 'numpy.ndarray'>
%}!}
The buffer will be filled with the most recent 10 samples, where $\textrm{buf}[9]$ is current one and $\textrm{buf}[0]$ is the oldest. One thing we haven't talked about is how these samples are saved. By default, a samples is saved to the buffer only when the value is changed, for example, either \tag{b|rising edge} or \tag{b|falling edge}. For \tag{b|rising edge}, it means the current value is larger than the last value; while for \tag{b|falling edge}, the current value is smaller than the last value.
{!exec|firstRunOnly||{%
import os.path
import matplotlib
import matplotlib.pyplot as plt
import numpy as np
filename = "images/dump1.svg"
if not os.path.isfile(filename):
    plt.clf()
    plt.figure(figsize=[4,2])
    plt.step(range(11), [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], where='post')
    plt.xlim([0,10])
    plt.xlabel('t')
    plt.tight_layout()
    plt.savefig(filename)
filename = "images/dump2.svg"
if not os.path.isfile(filename):
    plt.clf()
    plt.figure(figsize=[4,2])
    plt.step(range(11), [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], where='post')
    plt.xlim([0, 10])
    plt.xlabel('t')
    plt.tight_layout()
    plt.savefig(filename)
filename = "images/dump3.svg"
if not os.path.isfile(filename):
    plt.clf()
    plt.figure(figsize=[4,2.2])
    plt.step(range(11), [2+x for x in [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]], where='post')
    plt.step([0.5*x for x in range(22)], [0, 1]*11, where='post')
    plt.xlim([0, 10])
    plt.xlabel('t')
    plt.tight_layout()
    plt.savefig(filename)

%}!}
In some application, it may work well. For example, if the output of the signal is shown as the following figure,
{!image||
./images/dump1.svg
!}
then at time $t=9$, the buffer will be $[0, 1, 0, 1, 0, 1, 0, 1, 0, 1]$, as expected. However, if the signal output is as the one shown in the figure below. The data in buffer may look like $[x, x, x, x, x, x, x, 0, 1, 0]$, where $x$ is the value either from the buffer initialization or previous samples, rather than $[0, 1, 0, 0, 0, 0, 0, 0, 0, 0]$. The result is not surprising since the simulation will only push the data to the buffer whenever the data is changed. However, the value does not changed within $t=[2,3,...10]$
{!image||
./images/dump2.svg
!}
You may want to only dump the data at the rising (or falling) edge. In this case, replace the above \tag{b|trace_buf} with
{!example_src||highlight|python||{%
>>> s.trace_buf('top.sig_cos', size=10, trigger='pos')
%}!}
Then the buffer will only be filled when the signal value is increased (compared to the last value). In particular, for the above figure, at $t=9$, the buffer will be $[x,x,x,x,x,x,x,x,x,1]$.

Similarly, you can also dump the signal only at its falling edge
{!example_src||highlight|python||{%
>>> s.trace_buf('top.sig_cos', size=10, trigger='neg')
%}!}

In some case, you may want to dump the signal at a fixed sampling clock. How could we do that with bsmedit? Actually it is also straightforward. What we talked so far is to only use the signal itself to dump the value. bsmedit also provide a way to trigger the dumpling with a \tag{strong|valid} signal; that is, the dumping can be triggered by the rising and/or falling edge of a valid signal
{!example_src||highlight|shell||{%
>>> s.trace_buf('top.sig_cos', size=10, valid='top.CLOCK', trigger='pos')
 %}!}
It tells bsmedit to allocate a buffer with size 10 and dump the value to it at each rising edge of the signal \tag{b|top.CLOCK}.
{!image||
./images/dump3.svg
!}
For example, for the signals shown in above figure, at $t=9$, the buffer will be $[2, 3, 2, 2, 2, 2, 2, 2, 2, 2]$.

Since the value is dumped to a numpy, you can process the data with all the functions available (e.g., signal processing with [https://docs.scipy.org/doc/scipy/reference/signal.html|scipy.signal] or plot with [http://www.matoplotlib.org|matplotlib]) . And bsmedit also provides a function to plot the trace dynamically
{!example_src||highlight|python||{%
plot_trace(x=None, y=None, relim=True, *args, **kwargs)
%}!}
where
{{
    \tag{strong|x}| signal name for x-axis (e.g., 'top.sig_cos')||-
    \tag{strong|y}| signal name for y-axis (e.g., 'top.sig_sin')||-
    \tag{strong|relim}| automatically calculate the x & y limits||-
    \tag{strong|\*args, **kwargs}| additional arguments to Matplotlib plot function||-
}}
For example,
{!div|bs-example-src||highlight|python||{%
>>> plot_trace('top.sig_cos', 'top.sig_sin')
%}!}
Then when you run the simulation, the plot will be automatically updated accordingly
{!video||{%
./images/start_run_plot.mp4
%}!}
}
- {\tag{b|Dump signal to a file.}
{!example_src||highlight|python||
s.\sim_interface_args{trace_file}
!}
 where
 {!highlight|shell||
 \sim_interface_docs{trace_file}
 !}
For example, to trace the signal \tag{b|top.sig_sin} in to file \tag{b|top.sig_sin.bsm}
 {!example_src||highlight|python||
    s.trace_file(name='top.sig_sin')
 !}
}
-{ \tag{b|Monitor signal in a propgrid window.}
{!example_src||highlight|python||
s.\sim_interface_args2{monitor}
!}
If \tag{b|progprid} is \tag{b|None} and no \tag{b|propgrid} window (see Sec. [#sec_propgrid] for details) has been created, bsmedit will create one and add the signal to it.
For example, the following line will monitor signal \tag{b|top.sig_double} in the active propgrid
{!example_src||highlight|python||
s.monitor('top.sig_double')
!}
}
- {\tag{b|Breakpoints}. With the simulation control functions mentioned above, you can easily pause the simulation at particular simulation time. However, in some cases, you may want to pause the simulation when some conditions meet. The breakpoint is here to rescue.
To set a breakpoint,
{!example_src||highlight|python||{%
s.add_breakpoint(name, condition=None, hitcount=None)
%}!}
where
{{
    \tag{strong|name}|the signal name (e.g., \tag{b|top.sig_cos})||-
    \tag{strong|condition}| the breakpoint condition (optional)||-
    \tag{strong|hitcount}| the hit count condition (optional)||-
}}
bsmedit will check the breakpoint at each SystemC \tag{b|delta} cycle. Once the breakpoint condition is true (or signal value is changed if condition is \tag{b|None}), it will pause the simulation.

The breakpoint condition can be any valid python statement, for example
{!example_src||highlight|python||{%
s.add_breakpoint('top.sig_cos', '$>=0.9', None)
%}!}
Here \tag{code|\$} will be replaced with the signal value before checking breakpoint condition. Then, bsmedit will pause the simulation whenever its value is larger than \tag{b|0.9}.

You can also set the hit count, for example,
{!example_src||highlight|python||{%
s.add_breakpoint('top.sig_cos', '$>=0.9', '#==4')
%}!}
Again, \tag{code|\#} will be replaced with the hit count. The breakpoint will only be triggered if the breakpoint condition has been true for at least 4 \tag{b|delta} cycles. In other words, the breakpoint has been hit for at least 4 times.

You can also retrieve all the breakpoints by
{!example_src||highlight|shell||{%
>>> s.get_breakpoint()
[['top.sig_cos', None, None]]
%}!}

To delete a breakpoint,
{!example_src||highlight|python||{%
s.del_breakpoint('top.sig_cos', None, None)
%}!}
Here you also need to provide the full definition of the breakpoint, since multiple breakpoints may share the same signal, and/or breakpoint condition, and/or hit-count condition.

The breakpoint here is different from the one when you debug the C/C++/SystemC source code. For example, if you add the same breakpoint 5 times, it will not be cleared until you delete all 5 instances.
{!example_src||highlight|shell||{%
>>> bp = ['top.sig_cos', None, None]
>>> # add one
>>> s.add_breakpoint(*bp)
>>> s.get_breakpoint()
[['top.sig_cos', None, None]]
>>> # add it again
>>> s.add_breakpoint(*bp)
>>> s.get_breakpoint()
[['top.sig_cos', None, None], ['top.sig_cos', None, None]]
>>> # delete one
>>> s.del_breakpoint(*bp)
>>> s.get_breakpoint()
[['top.sig_cos', None, None]]
%}!}
After all these steps, there is still a breakpoint. You can use the \tag{b|get_breakpoint} command to confirm. Thus, it will still pause the simulation once its condition is met. At first sight, such behavior seems annoying, useless and confusing (as in most debugger, you may only set one breakpoint at each single line). However, since a signal can be added to propgrid window multiple times, and you may enable the breakpoint by clicking the radio button (as shown in the section below), it may cause confusion if bsmedit only keeps one instance of each distinct breakpoint. That is, bsmedit may have deleted the breakpoint, but the propgrid window shows it is still valid. So each \tag{b|add_breakpoint} needs to be explicitly canceled by one \tag{b|del_breakpoint}.
}
-{\tag{b|Multiple simulations.} Version 2 only supports running one simulation. So to run multiple simulations, you need to run multiple bsmedit. It is not very convenient to compare the results from multiple simulations. For example, it is impossible to show results from different simulations in a single plot (actually you may be able to do so by dumping the data to files). In version 3, bsmedit supports running multiple simulations simultaneously (each in its separate process). In this way, you can even run the same simulation in multiple processes; and each one is independent to the others. For example, the following commands will run the same simulation core in two separate processes. With that, you can configure the simulation differently to compare the result.
{!example_src||highlight|shell||{%
>>> s1 = simulation(None, './examples/start.dll')
>>> s2 = simulation(None, './examples/start.dll')
%}!}
{!image||
./images/start_run_script_multi.png
!}

To differentiate the simulations, each simulation will automatically be assigned an \tag{b|id} (e.g., 1,2,3...).

With that \tag{b|id}, you can retrieve the simulation handler later by
{!example_src||highlight|shell||{%
>>> s1 = simulation(1)
%}!}
which will return the handler to \tag{b|Simulation-1}.
}
== Propgrid window \label{sec_propgrid}
As shown above, each signal in \tag{b|propgrid} has two sections: label and value. #The value section shows its current value. When click on the \tag{code|value} section, if the signal is writable, the signal will be in edit mode; by default, an editbox will be shown so that you can type the value. By typing  "\tag{code|Enter}" after modifying the value, bsmedit will send the change to the simulation.
{!image||
./images/prop_signal.png
!}

\tag{b|Order the signals}. In general, the signals are shown in a propgrid window according to the order they are added. However, you can easily re-order the signals. There are two ways to do so
* drag the signal to the new destination
* select the signal (the selected signal will be highlighted)
*- {right click on the signal to show the context menu
{!image||
./images/prop_move.png
!}
}
*- or press \tag{b|Ctrl/Cmd+Up}/\tag{b|Ctrl/Cmd+Down} to move the signals up/down.

\tag{b|Group multiple signals together}. Right click on a signal to show the context menu, and click the \tag{b|Increase Indent}
{!image||
./images/prop_indent.png
!}
Then bsmedit will increase the indent of the signal, and the signal will effectively becomes the child of the previous signal (with smaller indent level).
{!image||
./images/prop_group.png
!}
You can also use script to change the indent level
{!example_src||highlight|python||{%
>>> # get the propgrid window with id=1
>>> g = propgrid(1)
>>> # get the handle of the property (assume it has already been added to the
>>> # propgrid window. Since the properties in each propgrid window may monitor
>>> # signals from multiple simulations, and they may have same name, here the
>>> # signal name is the global name. In other words, the original signal name is
>>> # prepended with its simulation id.
>>> p = g.Get("1.top.sig_sin")
>>> # to increase the indent by one level
>>> p.SetIndent(p.GetIndent()+1)
>>> # to decrease the indent by one level; the minimal indent level is 0
>>> p.SetIndent(p.GetIndent()-1)
%}!}

You can click the \tag{b|+}/\tag{b|-} button to show/hide the children.
{!example_src||highlight|python||{%
>>> p = grid.Get("1.top.sig_steps")
>>> # show the children signals
>>> p.SetExpand(True)
>>> # hide the children signals
>>> p.SetExpand(False)
%}!}

\tag{b|Use the control to set the signal}. As you see before, each signal in the \tag{b|propgrid} has two sections: name and value. The value section shows its current value. When click on the \tag{b|value} section, if the signal is writable, the signal will be in \tag{b|edit} mode; by default, an editbox will be shown so that you can type the value. By typing  \tag{b|Enter} after modifying the value, bsmedit will send the change to the simulation.
{!image||
./images/prop_editbox.png
!}

Besides the editbox, the following types of controls can be used to update the signal values
-{Combobox
{!image||
./images/prop_combobox.png
!}

You can right click on the signal and select 'Properties' from the context menu to change the window type in edit mode. Besides that, it can also be changed by python script:
{!example_src||highlight|python||{%
p = g.Get('1.top.sig_steps')
p.SetControlStyle('Choice', choice=[256, 1024, 2048, 8192, 16384])
%}!}
}
-{Slider
{!image||
./images/prop_slider.png
!}
{!example_src||highlight|python||{%
p.SetControlStyle('Slider', min_value=256, max_value=16384)
%}!}
}
-{Spin
{!image||
./images/prop_spin.png
!}
{!example_src||highlight|python||{%
p.SetControlStyle('Spin', min_value=256, max_value=16384)
%}!}
}
-{Checkbox
{!image||
./images/prop_checkbox.png
!}
{!example_src||highlight|python||{%
p = g.Get('1.top.sig_sc_bit')
p.SetControlStyle('CheckBox')
%}!}
}
-{Radio box
{!image||
./images/prop_radiobox.png
!}
{!example_src||highlight|python||{%
p = g.Get('1.top.sig_logic')
p.SetControlStyle('RadioBox', choice=['1', '0', 'Z', 'X'])
%}!}
}
-Color picker
-Select File/Folder button

#-supported format:String,Dec,Hex,Oct,Bin

As shown above, you can set the breakpoint with script. You can also set the breakpoint in \tag{propgrid} window by clicking the radio button next to the signal name:
{!image||
./images/prop_breakpoint.png
!}
bsmedit will check the breakpoint at each SystemC \tag{b|delta} cycle. Once the condition is true, it will pause the simulation.
The breakpoint can also be enabled by python script:
{!example_src||highlight|python||{%
p.SetChecked(True)
%}!}

Then, if you run the simulation, it will be paused once the signal value is changed or the simulation time is reached. You can also set the breakpoint conditions here. Right click on the signal and click '\tag{b|Breakpoint Condition}' (the menu item is not clickable unless the radio button is checked)
{!image||
./images/prop_bpcondition.png
!}
When the "\tag{b|Is true}" radio button is checked, the condition editbox will be enabled for input. For example, "\tag{b|\$>0.1}" will pause the simulation when the signal value is greater than 0.1, where "\tag{b|\$}" will be replaced by the signal value. Breakpoint condition can also be set by
{!example_src||highlight|python||{%
p.SetBpCondition('$>0.1','')
%}!}

When hit count is set (e.g. \tag{b|\#==4}), the breakpoint will only be triggered if the breakpoint condition has be met for certain amount of delta cycles (e.g., 4 delta cycles).

{!example_src||highlight|python||{%
p.SetBpCondition('$>0.1','#==4')
%}!}
== SystemC Simulation
From version 3, bsmedit supports SystemC 2.3. Once a simulation is loaded, bsmedit will have access to the following data types
-bool
-float, double
-char, unsigned char
-short, unsigned short
-int, unsigned int
-long, unsigned long
-long long, unsigned long long
-sc_logic, sc_bit
-sc_lv, sc_bv
-sc_int, sc_uint
-sc_bigint, sc_biguint
-sc_fixed
-sc_fixed_fast
-sc_ufixed
-std::string

And you can use the above function to read/write all the \tag{b|sc_signal}/\tag{b|sc_out}/\tag{b|sc_inout} objects, and read all the \tag{b|sc_in} objects.

To make bsmedit work, the simulation needs to implement and export some interfaces.
\tag{b|bsm.h/cpp} is the bridge between bsmedit and SystemC simulation. It implements the interfaces such that bsmedit can have access to all the objects and also control the simulation.
-{ create the top level module
{!example_src||highlight|c++||{%
void bsm_sim_top(sim_context *context);
%}!}
It is a first function bsmedit will call to create a simulation, where \tag{b|sim_context} is a struct to return simulation information to bsmedit. It is defined by the macro "\tag{b|BSMEDIT_IMPLEMENT_MODULE}"
{!example_src||highlight|c++||{%
typedef struct sim_context {
    char version[MAX_NAME_LEN];
    char copyright[MAX_NAME_LEN];
} sim_context;

#define BSMEDIT_IMPLEMENT_MODULE(T, name) extern bsm_sim_context* g_sim;\
extern "C" {\
    BSMEDIT_EXPORT void bsm_sim_top(sim_context *context) {\
        g_sim = new bsm_sim_context_impl(new T(name));\
        snprintf(context->copyright, MAX_NAME_LEN, "%s", g_sim->sc_copyright());\
        snprintf(context->version, MAX_NAME_LEN, "%s", g_sim->sc_version());\
    }\
}
%}!}

\tag{b|bsm_sim_top} creates the simulation context (i.e., \tag{b|g_sim}). Then, bsmedit can control the simulation through all the other interfaces defined in \tag{b|bsm.h/cpp} with that handler.
}
#-{ enumerate the objects
#{!example_src||highlight|c++||{%
#bool ctx_first_object(sim_object* obj);
#bool ctx_next_object(sim_object* obj);
#bool ctx_free_object(sim_object* obj);
#%}!}
#Once bsmedit creates a simulation successfully, it will try to load all the objects defined in the simulation with the above functions.
#If there is any objects accessible by bsmedit, the first function will return \tag{code|true} and fill the \tag{code|sim_object} struct. Again, the actual definition of \tag{code|sim_object} is not very important. Similarly, the second function will return the next accessible object, if available. The last function is used to clear the memory once bsmedit finishes using the object, for example, when the simulation exits.
#}
#-{function to read/write the objects.
#{!example_src||highlight|c++||{%
#bool ctx_read(sim_object* obj);
#bool ctx_write(sim_object* obj);
#%}!}
#}
#- { control the simulation
#{!example_src||highlight|c++||{%
#void ctx_start(double duration, int unit);
#void ctx_stop();
#%}!}
#\tag{code|ctx_start} runs the simulation for a period indicated by \tag{strong|duration} and \tag{strong|unit}. In particular, the simulation will pause after that duration until another call. One exception is the breakpoint callback. When the simulation is running, it will keep check the breakpoint condition. If any breakpoint condition satisfies, the simulation will pause immediately.
#
#\tag{ctx_stop} will destroy the simulation. After calling this function, the simulation will be released and all objects may not be available.
#}
#- { time stamp
#{!example_src||highlight|c++||{%
#double ctx_time();
#bool ctx_time_str(char* time);
#%}!}
#The first function returns the current time-stamp of the simulation in seconds. The second function returns a string, which may contain the time-stamp unit. bsmedit will use such time-stamp to determine whether the simulation should be paused or not.
#}
#- { set the callback
#{!example_src||highlight|c++||{%
#void ctx_set_callback(bsm_sim_context::bsm_callback fun);
#%}!}
#It is used for achieve the breakpoint feature. At each 'delta' cycle, the simulation should call the callback function. And if the callback function returns \tag{code|1}, the simulation should pause immediately. Here the 'delta' cycle means the minimum simulation unit.
#}
#- { dump the object to a file
#{!example_src||highlight|c++||{%
#bool ctx_create_trace_file(sim_trace_file* t);
#bool ctx_trace_file(sim_trace_file* t, sim_object* obj, sim_object* val, int trigger);
#bool ctx_stop_trace_file(sim_trace_file* t);
#%}!}
#The first function creates a tracefile. It should always be called first. The second function adds a actual object to the tracefile created through the first function. Finally, the last function stops the tracefile, so that no more object values will be dumped to the tracefile.
#}
#- { dump the object to a buffer
#{!example_src||highlight|c++||{%
#bool ctx_create_trace_buf(sim_trace_buf* t);
#bool ctx_trace_buf(sim_trace_buf* t, sim_object* obj, sim_object* val, int trigger);
#bool ctx_stop_trace_buf(sim_trace_buf* t);
#bool ctx_read_trace_buf(sim_trace_buf* t);
#bool ctx_resize_trace_buf(sim_trace_buf* t);
#%}!}
#Same as the functions to dump the object to a file, these functions are used to dump the object to a buffer. Two more functions are defined to read and resize the buffer, respectively.
#}
=== xsc_property
With SystemC's \tag{b|sc_signal}, it is very easy to simulate a \tag{b|register} in simulation. For example, you can configure the simulation by changing the values of some \tag{b|sc_signal} without updating and re-compiling the source code. However, sometime you (the simulation) may want to know when the configuration is updated. For example, the simulation may want to log the configuration value once it is changed. Thus we derive the \tag{b|xsc_property} from \tag{b|sc_signal}.

Its usage is almost exactly same as sc_signal. It supports all the data type supported by sc_signal.
{!example_src||highlight|c++||{%
class MyModule:public sc_module {
public:
    MyModule(sc_module_name name_):
            tx_module(name_)
            ,xsc_prop_double("xsc_prop_double", this, xsc_callback_fun) {
        //set the value and don't call the callback function
    }
    xsc_property<double> xsc_prop_double;
    static void xsc_callback_fun(sc_module* pThis, double value);
};
%}!}
In this example, we define a double type \tag{b|xsc_property}. During its initialization, three parameters are passed into its constructor function:
* its name derived from \tag{b|sc_signal},
* the pointer to the current \tag{b|sc_module},
* the pointer to a static function.
Now, when bsmedit sends the following command to the simulation (here assume the name/path of the \tag{b|xsc_property} is "\tag{b|top.mymodule.xsc_prop_double}")
{!example_src||highlight|shell||{%
>>> # s is the simulation handle
>>> s.write("top.mymodule.xsc_prop_double", 1.0)
%}!}
The callback function \tag{b|xsc_callback_fun} will be called, where its first parameter will be the pointer of the \tag{b|sc_module} that defined the \tag{b|xsc_property}, and the second parameter will be '1.0'.

The callback function should have the following format
{!example_src||highlight|c++||{%
typedef void(*xsc_callback)(sc_module* pThis, T value);
%}!}

Sometime, you may want to only execute the callback function when it is updated externally (e.g., by bsmedit), but not internally (e.g., by the simulation itself). In this case, in your simulation code (e.g., C++), you may
{!example_src||highlight|c++||{%
xsc_prop_double.write_nc(128.0);
%}!}
In this way, \tag{b|xsc_property} behaves exactly same as \tag{b|sc_signal}, and no callback function will be called.

=== xsc_array
\tag{b|xsc_array} is a natural extension of \tag{b|xsc_property}. It is actually an array of the \tag{b|xsc_property}
{!example_src||highlight|c++||{%
class MyModule:public sc_module {
public:
     MyModule(sc_module_name name_)
     : sc_module(name_)
     , xscarray_int("xsc_array_int") {
         // set the value
         xsc_array_int[0] = 1;
         xsc_array_int[1].write(1);
         // get the value
         int a = xsc_array_int[0];
         int b = xsc_array_int[1].read();
     }
     xsc_array<int, 5> xsc_array_int;
  };
 %}!}

The above example show to use \tag{b|xsc_array} in a \tag{b|sc_module}. It define an integer \tag{b|xsc_array} with size 5. In the module's constructor, the \tag{b|xsc_arrary} is initialized with name \tag{b|xsc_array_int}. And it also shows the basic usage of \tag{b|xsc_array}. Basically, it behaves as an array of \tag{b|xsc_property}. You can use the \tag{b|\[i\]} to have access to the $i$th item in the array.

Same as \tag{b|xsc_property}, \tag{b|xsc_array} also supports a callback function. For example
{!example_src||highlight|c++||{%
class MyModule:public sc_module {
public:
     MyModule(sc_module_name name_)
     : sc_module(name_)
     , xscarray_int("xsc_array_int", this, xsc_callback_fun) {
     }
     xsc_array<int, 5> xsc_array_int;
     static void xsc_callback_fun(sc_module* pThis, double value);
  };
%}!}

In bsmedit, the item of the array can be accessed by its name. For example, if in the simulation, the above \tag{b|MyModule} is a top level module with name "\tag{b|top}", the first item of the \tag{b|xsc_array_int} can be accessed by
{!example_src||highlight|shell||{%
>>> s.read('top.xsc_array_int[0]')
%}!}


== C/C++ Simulation
For SystemC simulation, bsmedit pre-defines some interfaces, which are implemented by each simulation. Then, bsmedit retrieves these interfaces to control the simulation (e.g., via ctypes). Same idea can be extended to any C/C++ simulation.

For example, assume your C/C++ code generates a 2D wave (e.g., received from a sensor). You may define the interface as
{!example_src||highlight|c++||ccodesnippet||
../examples/waves/waves.h
!}

The \tag{b|wave_frame} struct defines the data format sent to bsmedit:
-the values and its dimension;
-the \tag{b|callback} to notify bsmedit that new data is arrived.

\tag{b|get_frame} function is used to send one frame of data to bsmedit; and \tag{b|get_frames} is to retrieve all the frames (e.g., imaging the C/C++ code is keeping receiving data from the sensor). For this demo, we simply generate a 2D sine wave
{!example_src||highlight|c++||ccodesnippet||
../examples/waves/main.c
!}
And the makefile may look like

{!example_src||highlight|makefile||ccodesnippet||
../examples/waves/Makefile
!}

To generate the library

{!example_src||highlight|shell||{%
$ make
%}!}

Now the library is ready, let's start to build the python interface so that it can communicate with bsmedit.
One way is to use [https://docs.python.org/3.6/library/ctypes.html| ctypes] directly.
*{Import the ctypes package
{!example_src||highlight|python||{%
>>> from ctypes import *
%}!}}
*{Create the corresponding \tag{b|wave_frame} structure in python
{!example_src||highlight|python||{%
>>> class wave_frame(Structure):
...     SIM_CALLBACK = CFUNCTYPE(c_int, c_int)
...     _fields_ = [('rows', c_int),
...                 ('cols', c_int),
...                 ('frame', POINTER(c_float)),
...                 ('max_frame_len', c_int),
...                 ('callback', SIM_CALLBACK),
...                ]
%}!}}
*{Load the library built above
{!example_src||highlight|python||{%
>>> dll = cdll.LoadLibrary('libwaves.so')
%}!}}
*{Retrieve the interface, and set the \tag{b|return} and \tag{b|argument} types accordingly
{!example_src||highlight|python||{%
>>> get_frame = dll.get_frame
>>> get_frame.argtypes = [POINTER(wave_frame)]
>>> get_frame.restype = None
%}!}
}
*{Call the interface to get the data dimension, which is done by calling \tag{b|get_frame} without allocating data memory
{!example_src||highlight|python||{%
>>> frame = wave_frame()
>>> get_frame(frame)
%}!}
}
*{Allocate memory
{!example_src||highlight|python||{%
>>> frame.max_frame_len = frame.rows*frame.cols
>>> frame_array = np.zeros(frame.max_frame_len).astype(np.float32)
>>> frame.frame = frame_array.ctypes.data_as(POINTER(c_float))
%}!}
}
*{Get the wave
{!example_src||highlight|python||{%
>>> get_frame(frame)
%}!}
 }
*{Plot with matplotlib
{!example||image||
./images/waves.png
!}
{!example_src||highlight|python||{%
>>> x = np.meshgrid(np.arange(frame.rows), np.arange(frame.cols))
>>> fig = figure()
>>> ax = fig.add_subplot(projection='3d')
>>> ax.plot_surface(x[0], x[1], frame_array.reshape(frame.rows, frame.cols))
%}!}
}
It is very flexible to build the python interfaces with ctypes directly. However, it is also tedious and error prone, especially when there are a lot of interfaces or the interfaces may change frequently. bsmedit provides an alternative way to automatically generate python interfaces from the header file, that is
{!example_src||highlight|python||{%
bsmedit.bsm.csim.init_dll(dll, header)
%}!}
where \tag{b|dll} is the compiled library, and \tag{b|header} is the corresponding header files, which defines all the interfaces. The function will return the python wrapper.
Thus, the above example can be achieved by
{!example_src||highlight|python||{%
>>> import bsmedit.bsm.csim as csim
>>> sim = csim.init_dll('./libwaves.so', './waves.h')
>>> f = sim.wave_frame()
>>> sim.get_frame(f)
>>> f.max_frame_len = f.rows*f.cols
>>> frame = np.zeros(f.max_frame_len).astype(np.float32)
>>> f.frame = frame.ctypes.data_as(POINTER(c_float))
>>> sim.get_frame(f)
%}!}
The nice thing is that whenever the interfaces in header file (i.e., \tag{b|waves.h}) is updated, just call \tag{b|csim.init_dll} again (e.g., restart simulation), which will return the updated interface.

bsmedit also provides a class to to show the 3D image easily in python; the full example can be found [https://github.com/tianzhuqiao/bsmedit/tree/master/examples/waves|here].
Run the following command to show wave in bsmedit
{!example_src||highlight|shell||{%
$ bsmedit -i -p examples/waves waves
%}!}
{!video||
./images/waves.mp4
!}

#{!exec|firstRunOnly||{%
#def bsmdoc_ccodesnippet2(data, args, **kwargs):
#    import inspect
#    import os.path
#    import sys
#    import importlib
#    sys.path.append(os.path.split(args[0])[0])
#    pkg = os.path.splitext(os.path.split(args[0])[1])[0]
#    print(pkg, args[0])
#    mod = importlib.import_module(pkg)
#    d = eval("mod.%s"%args[1])
#    return inspect.getsource(d)
#%}!}
#{!example_src||highlight|python||ccodesnippet2|../examples/waves/waves.py|Wave||
#!}

= Misc.
== VCD/CSV/Mat/ULog
When [https://github.com/tianzhuqiao/bsmplot|bsmplot] is installed, bsmedit will also be able to visualize VCD/CSV//Mat/ULog time series. For example,
[https://docs.px4.io/main/en/dev_log/ulog_file_format.html|ULog] is the file format used in PX4 for message logging. The ulog plugin is to load and visualize the ulog messages. When open a ulog file (\tag{b|menu->open->ulog file}), bsmedit will create a panel to show its content. Different types of message are shown in different tab.
{!image||
./images/ulog_panel.png
!}

For a ulog file that has many messages, you can use the searching box to filter messages.
{!image||
./images/ulog_panel_filter.png
!}

You can also export the data to the terminal by right click on it
{!image||
./images/ulog_panel_menu.png
!}

To visualize the data, you can either
* double click on the data, and it will on the current figure (create one automatically if no figure exists)
* drag the data to some figure
{!image||
./images/ulog_panel_plot2.png
!}
